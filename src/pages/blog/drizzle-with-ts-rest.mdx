---
layout: "../../layouts/BlogPost.astro"
title: "Introducing Drizzle ORM and ts-rest: Simplifying the Typescript Stack"
description: "This is a common antipattern we need to collectively avoid"
pubDate: "May 20, 2023"
heroImage: "../../images/useffect-post.jpg"
---

import Gif from "../../components/Gif.astro";
import { Image } from "astro:assets";

In the ever-evolving landscape of Typescript development, a new ORM has emerged as the latest sensation - Drizzle ORM. This powerful tool offers similar functionality to Prisma but distinguishes itself by eliminating the need for a build step, query engine, and long cold start times. As someone who has recently embraced Drizzle ORM in production, I am thrilled to share my experience and demonstrate how it can be seamlessly integrated with ts-rest to create a streamlined and comprehensive Typescript stack.

## Exploring Drizzle

> Drizzle ORM is a TypeScript ORM for SQL databases designed with maximum type safety in mind. It comes with a drizzle-kit CLI companion for automatic SQL migrations generation. Drizzle ORM is meant to be a library, not a framework. It stays as an opt-in solution all the time at any levels. - [drizzle GitHub](https://github.com/drizzle-team/drizzle-orm)

Before diving into the details of combining Drizzle and ts-rest, let's begin by understanding what Drizzle actually is. At its core, Drizzle is an ORM specifically designed for Typescript. It functions as a library that enables developers to define their database schema using Typescript and subsequently utilize this schema to execute queries on the database.

In this section, we will delve into the key features of Drizzle and explore how it simplifies the interaction with the database, eliminating many of the complexities developers typically face.

## Unveiling ts-rest

> ts-rest was designed for and by TS-first teams who want to improve the stability and safety without a large investment into a new solution/tech (such as GraphQL), and need a simple, safe API with a focus on DX and adoption speed. - [ts-rest.com](https://ts-rest.com/)

While Drizzle revolutionizes the database interaction, ts-rest complements it by simplifying the communication with APIs. Originating as a personal project, ts-rest has now evolved into a robust library with a dedicated team, a thriving community, and a proven track record in production environments. By allowing developers to define their API schema in Typescript, ts-rest facilitates seamless querying of APIs.

In this section, we will take a closer look at ts-rest, its features, and how it seamlessly integrates with Drizzle to create a cohesive Typescript stack.

## Same-same but different

Drizzle and ts-rest share a similar philosphy of "if you know [sql/rest], you know [drizzle/ts-rest]", which makes them a great fit for each other. Drizzle is a Typescript ORM for SQL databases, while ts-rest is a Typescript library for querying REST APIs. Both libraries are designed to be intuitive and familiar for developers experienced in working with SQL and REST APIs, respectively. This shared philosophy enables developers to leverage their existing knowledge and seamlessly transition to Drizzle and ts-rest.

<Gif
  url="https://media1.giphy.com/media/uNE1fngZuYhIQ/giphy.gif?cid=ecf05e47ryj9dsfwsxpg1g395458mwcz84rvg3enn3c54n62&ep=v1_gifs_search&rid=giphy.gif&ct=g"
  alt="same-same but different meme"
/>

Drizzle and ts-rest strive to create a unified and consistent development experience. With Drizzle, developers define their database schema using Typescript, providing type safety and leveraging the benefits of static typing. Similarly, ts-rest enables developers to define their API schema in Typescript, ensuring type safety throughout the development process. This unification of Typescript-based schemas across both the database and API layers creates a cohesive development experience, reducing friction and enabling seamless integration.

Get ready to embark on a journey where we unravel the potential of Drizzle ORM and ts-rest, discovering the simplicity they bring to Typescript development. Join me as we explore their functionalities, examine their integration, and unlock the true power of a comprehensive Typescript stack.

## Getting started already

Lets keep this basic and start with a simple Next.js app, due to the lack runtime complexity as you'd find with tools like Prisma, Drizzle is a great pairing for serverless environments like Vercel.

### 1. Create a Next.js app [view commit](https://github.com/oliverbutler/drizzle-ts-rest/commit/178b360bf9b517e54fe2cee8d2fc33be32f98d92)

```bash
pnpm create next-app
```

We're going to keep the default options here.

```
âœ” What is your project named? â€¦ drizzle-ts-rest
âœ” Would you like to use TypeScript with this project? â€¦ No / Yes
âœ” Would you like to use ESLint with this project? â€¦ No / Yes
âœ” Would you like to use Tailwind CSS with this project? â€¦ No / Yes
âœ” Would you like to use `src/` directory with this project? â€¦ No / Yes
âœ” Use App Router (recommended)? â€¦ No / Yes
âœ” Would you like to customize the default import alias? â€¦ No / Yes
Creating a new Next.js app in /Users/olly/projects/drizzle-ts-rest.
```

### 2. Setup an API contract [view commit](https://github.com/oliverbutler/drizzle-ts-rest/commit/51e95fae28dc46631ec35ca099266343ba2db99e)

```bash
pnpm add zod @ts-rest/core @ts-rest/next
```

Let's make a shared API contract for our REST API, this will be used by both the client and server to ensure type safety.

```ts
// server/contract.ts

import { initContract } from "@ts-rest/core";
import { z } from "zod";

const c = initContract();

export const TodoSchema = z.object({
  id: z.number(),
  text: z.string(),
});

export type Todo = z.infer<typeof TodoSchema>;

export const apiContract = c.router({
  getTodos: {
    method: "GET",
    path: "/todo",
    responses: {
      200: TodoSchema.array(),
    },
  },
  createTodo: {
    method: "POST",
    path: "/todo",
    body: z.object({
      text: z.string(),
    }),
    responses: { 200: TodoSchema },
  },
});
```

### 3. Setup the Next.js endpoints [view commit](https://github.com/oliverbutler/drizzle-ts-rest/commit/c32489dd1563df030ace8a8e2ac0314b72adcb2a)

Now lets use ts-rest to create a catch-all Next.js route that will handle all of our API requests!

You'll notice once you pass `apiContract` as the first parameter to `createNextRoute` that the second parameter becomes auto-magically typed, this is because ts-rest is able to infer the type of the contract and apply it to the router - giving you complete type safety. Magic stuff.

```ts
// pages/api/[...ts-rest].ts

import { Todo, apiContract } from "@/server/contract";
import { createNextRoute, createNextRouter } from "@ts-rest/next";

const router = createNextRoute(apiContract, {
  getTodos: async (args) => {
    return {
      status: 200,
      body: [],
    };
  },
  createTodo: async ({ body }) => {
    const newTodo: Todo = {
      id: "123",
      ...body,
    };

    return {
      status: 200,
      body: newTodo,
    };
  },
});

export default createNextRouter(apiContract, router, {});
```

### 2. Setup Drizzle ORM

Now we've got a basic REST API, let's get to the start of the show - Drizzle ORM.

In this case I'm going to make use of SQLite to simplify things, please refer to Drizzles documentation for more information on how to use other databases - [connection docs](https://orm.drizzle.team/docs/installation-and-db-connection)

```bash
pnpm add drizzle-orm better-sqlite3
pnpm add -D drizzle-kit
```

Below we're setting up drizzle to connect to a local SQLite database, create a table, and expose a simple API for interacting with it in a type-safe way.

> Please note Drizzle fully supports migrations, but I want to keep it simple for this example whilst proving that Drizzle works great for existing/brownfield databases out of it's control (a little unlike Prisma who prefers it when you let it manage your database)

```ts
// server/main.ts

import { drizzle, BetterSQLite3Database } from "drizzle-orm/better-sqlite3";
import { sqliteTable, text, int } from "drizzle-orm/sqlite-core";
import { eq } from "drizzle-orm";
import Database from "better-sqlite3";

const sqlite = new Database("sqlite.db");
const db: BetterSQLite3Database = drizzle(sqlite);

sqlite.exec(`
  CREATE TABLE IF NOT EXISTS todos (
    id INTEGER PRIMARY KEY,
    text TEXT NOT NULL
  );
`);

export const todos = sqliteTable("todos", {
  id: int("id").primaryKey(),
  text: text("text").notNull(),
});

export const getTodos = async () => {
  const result = await db.select().from(todos).all();

  return result;
};

export const createTodo = async (text: string) => {
  const result = await db.insert(todos).values({ text }).run();

  if (result.changes !== 1) {
    throw new Error("Failed to create todo");
  }

  return getTodo(result.lastInsertRowid as number);
};

export const getTodo = async (id: number) => {
  const [result] = await db.select().from(todos).where(eq(todos.id, id)).all();

  return result;
};
```

We can now use these functions in our Next.js API routes, and because we're using Drizzle we get full type safety and auto-completion for our DB calls - whilst ts-rest makes sure we return the correct response type ðŸ¥³.

```ts
// ...
  getTodos: async (args) => {
    const todos = await getTodos(); // <- fully typed!

    return {
      status: 200,
      body: todos, // <- also fully typed!
    };
  },
  createTodo: async ({ body }) => {
    const todo = await createTodo(body.text);

    return {
      status: 200,
      body: todo,
    };
  },
// ...
```

You can see the power of this if we make a mistake, in this below example we accidentally returned the body as an object containing `todo` instead of just the todos array itself - a trivial mistake, but one that we can now catch at compile time.

<Image
  src={import("../../images/drizzle/ts-rest-example-error.png")}
  alt="ts-rest-example-error"
  loading="lazy"
/>

### 3. Setup the client
